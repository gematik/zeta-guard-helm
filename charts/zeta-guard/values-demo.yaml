ingress_controller:
  enabled: false

management_service:
  enabled: false

service_mesh:
  enabled: false

authserver:
  hostname: ""
  http_enabled: true
  config:
    maxClients: "256"

pepproxy:
  image:
    pullPolicy: Always
  nginxConf:
    generateConfigMap: true

    fachdienstUrl: https://fachdienst
    pepIssuer: http://authserver/auth/realms/zeta-guard
    requiredAudience: "test"
    requiredScopes: [ ]

    locations: |-
      location / {
        root /usr/share/nginx/html;
        pep on;
        pep_require_popp off;
      }
      # Proxy OAuth Authorization Server metadata to Keycloak (demo)
      # Served as: http://<host>/.well-known/oauth-authorization-server
      # Target:   http://authserver/auth/realms/zeta-guard/.well-known/zeta-guard-well-known
      location = /.well-known/oauth-authorization-server {
        proxy_pass http://authserver/auth/realms/zeta-guard/.well-known/zeta-guard-well-known;
        proxy_http_version 1.1;
      }

# DB mode switch:
# - bitnami: local using Bitnami subchart service/secret
# - operator: staging/dev/prod using Zalando Postgres Operator
databaseMode: bitnami
postgresql:
  image:
    repository: bitnamilegacy/postgresql
  enabled: true
  auth:
    username: keycloak
    password: devpassword
    database: keycloak
  primary:
    persistence:
      enabled: false

# Which cert-manager ClusterIssuer to use for TLS on the Ingress (default)
clusterIssuer: "letsencrypt-cd"

opa:
  logLevel: info
  enabled: true
  # For demo, use inline policy by default so no registry credentials are required.
  bundle:
    # use Workload Identity Federation or secretRef when enabling bundle mode
    enabled: false
  workloadIdentityFederation:
    enabled: false
# Decision logs toggle used by both inline and bundle configs
opaPolicy:
  logDecisions: true
  # Example fake policy: allow-all decision object.
  # The policies should be loaded from PIP-PAP Service (workload identity federation or secretRef)
  policyRego: |
    package zeta.authz

    # Minimal decision object compatible with callers expecting
    # data.zeta.authz.decision => {"allow": bool, "ttl": {"access_token": number, "refresh_token": number}}
    decision := {
      "allow": true,
      "ttl": {
        "access_token": 300,
        "refresh_token": 86400,
      },
    }

admissionWebhooks:
  certManager:
    enabled: true
