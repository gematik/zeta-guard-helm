ingress_controller:
  enabled: false

management_service:
  enabled: false

service_mesh:
  enabled: false

authserver:
  hostname: ""
  http_enabled: true
  config:
    maxClients: "256"

pepproxy:
  image:
    pullPolicy: Always
  nginxConf:
    generateConfigMap: true

    fachdienstUrl: https://fachdienst
    pepIssuer: http://authserver/auth/realms/zeta-guard
    poppIssuer: "http://localhost"
    requiredAudience: "test"
    requiredScopes: [ ]

    locations: |-
      location / {
        root /usr/share/nginx/html;
        pep on;
        pep_require_popp off;
      }
      # Proxy OAuth Authorization Server metadata to Keycloak (demo)
      # Served as: http://<host>/.well-known/oauth-authorization-server
      # Target:   http://authserver/auth/realms/zeta-guard/.well-known/zeta-guard-well-known
      location = /.well-known/oauth-authorization-server {
        proxy_pass http://authserver/auth/realms/zeta-guard/.well-known/zeta-guard-well-known;
        proxy_http_version 1.1;
      }

# DB mode switch:
# - bitnami: local using Bitnami subchart service/secret only for demo purposes â€“ no support at all
# - operator: staging/dev/prod using Zalando Postgres Operator
# - external: use external db by providing filling values authserverDb.kcDb, authserverDb.kcDbUrl,
#       authserverDb.kcDbSchema, authserverDb.kcDbUsername, authserverDb.kcDbPasswordSecretName
#       the db password is pulled from the "password" field of a secret going by the provided name. The other properties
#       behave according to the keycloak environment variables. See https://www.keycloak.org/server/db
databaseMode: bitnami
postgresql:
  image:
    repository: bitnamilegacy/postgresql
  enabled: true
  auth:
    username: keycloak
    password: devpassword
    database: keycloak
  primary:
    persistence:
      enabled: false

# Which cert-manager ClusterIssuer to use for TLS on the Ingress (default)
clusterIssuer: "letsencrypt-cd"

opa:
  logLevel: info
  enabled: true
  # For demo, use inline policy by default so no registry credentials are required.
  bundle:
    # use Workload Identity Federation or secretRef when enabling bundle mode
    enabled: false
  workloadIdentityFederation:
    enabled: false
# Decision logs toggle used by both inline and bundle configs
opaPolicy:
  logDecisions: true
  # Example fake policy: allow-all decision object.
  # The policies should be loaded from PIP-PAP Service (workload identity federation or secretRef)
  policyRego: |
    package zeta.authz

    # Minimal decision object compatible with callers expecting
    # data.zeta.authz.decision => {"allow": bool, "ttl": {"access_token": number, "refresh_token": number}}
    decision := {
      "allow": true,
      "ttl": {
        "access_token": 300,
        "refresh_token": 86400,
      },
    }

admissionWebhooks:
  certManager:
    enabled: true
