{{- if .Values.gematikConnectionEnabled }}

{{- /* This CronJob is based on example Job from
     * https://docs.cloud.google.com/iam/docs/workload-identity-federation-with-kubernetes#deploy
     */}}

apiVersion: batch/v1
kind: CronJob
metadata:
  name: gematik-oidc-token-renewer-cronjob
  labels:
    app.kubernetes.io/name: opa
    app.kubernetes.io/managed-by: {{ .Release.Service }}
    app.kubernetes.io/instance: {{ .Release.Name }}
    app.kubernetes.io/part-of: zeta-guard
    app.kubernetes.io/component: gematik
spec:
  failedJobsHistoryLimit: 2
  schedule: "*/30 * * * *"
  successfulJobsHistoryLimit: 2
  jobTemplate:
    spec:
      backoffLimit: 5
      template:
        metadata:
          labels:
            app.kubernetes.io/name: opa
            app.kubernetes.io/managed-by: {{ .Release.Service }}
            app.kubernetes.io/instance: {{ .Release.Name }}
            app.kubernetes.io/part-of: zeta-guard
            app.kubernetes.io/component: gematik
          {{- if $.Values.devMode }}
          annotations:
            zeta.dev/rollout-timestamp: "{{ now | unixEpoch }}"
          {{- end }}
        spec:
          securityContext:
            seccompProfile:
              type: RuntimeDefault
          serviceAccountName: opa-token-renewer
          restartPolicy: OnFailure
          containers:
            - name: token-renewer
              image: google/cloud-sdk:549.0.0
              imagePullPolicy: IfNotPresent
              securityContext:
                runAsNonRoot: true
                runAsUser: 1000
                allowPrivilegeEscalation: false
                capabilities:
                  drop: ["ALL"]
              command: ["/bin/bash", "-c"]
              args:
                - |
                  set -euo pipefail
                  echo "Beginne Token-Erneuerung..."

                  # Sicherstellen, dass jq verf체gbar ist (Basis-Image enth채lt es evtl. nicht)
                  if ! command -v jq >/dev/null 2>&1; then
                    apt-get update -y && apt-get install -y jq && rm -rf /var/lib/apt/lists/* || true
                  fi

                  # 1. K8s Service Account Token aus dem projizierten Volume lesen
                  K8S_TOKEN=$(cat /var/run/secrets/sts.googleapis.com/serviceaccount/token)

                  # 2. Token beim GCP Security Token Service (STS) gegen ein GCP Access Token tauschen
                  {{- /* Authenticate a workload using the REST API
                       * See https://docs.cloud.google.com/iam/docs/workload-identity-federation-with-other-clouds#rest
                       * REST API reference: https://docs.cloud.google.com/iam/docs/reference/sts/rest/v1/TopLevel/token
                       */}}

                  # JSON-Payload f체r STS aufbauen
                  {{- $resourceNameOfIdentityProvider := include "gematik.full-resource-name-of-identity-provider" . }}
                  GCP_STS_SCOPE="https://www.googleapis.com/auth/cloud-platform"
                  read -r -d '' STS_PAYLOAD << JSON || true
                  {
                    "grant_type": "urn:ietf:params:oauth:grant-type:token-exchange",
                    "subject_token_type": "urn:ietf:params:oauth:token-type:jwt",
                    "requested_token_type": "urn:ietf:params:oauth:token-type:access_token",
                    "subject_token": "${K8S_TOKEN}",
                    "audience": "{{ $resourceNameOfIdentityProvider }}",
                    "scope": "${GCP_STS_SCOPE}"
                  }
                  JSON

                  # Debug: STS Payload (ohne sensiblen Token-Inhalt)
                  echo "STS Payload (redacted):" >&2
                  echo "$STS_PAYLOAD" | sed -E 's/("subject_token"\s*:\s*")([^"]+)(")/\1<REDACTED>\3/' >&2
                  echo "" >&2

                  # K8s JWT gegen kurzlebiges GCP Access Token eintauschen (mit Debug-Ausgabe)
                  HTTP_CODE=$(curl -s -o /tmp/sts.json -w "%{http_code}" -X POST \
                    "https://sts.googleapis.com/v1/token" \
                    -H "Content-Type: application/json" \
                    -d "$STS_PAYLOAD")
                  GCP_ACCESS_TOKEN=$(jq -r '.access_token' /tmp/sts.json 2>/dev/null || echo "")

                  if [ "$HTTP_CODE" != "200" ] || [ -z "$GCP_ACCESS_TOKEN" ] || [ "$GCP_ACCESS_TOKEN" = "null" ]; then
                    echo "FEHLER: STS Aufruf fehlgeschlagen (HTTP $HTTP_CODE)." >&2
                    echo "STS Antwort:" >&2
                    cat /tmp/sts.json >&2 || true
                    echo "" >&2
                    echo "Verwendete Audience: {{ $resourceNameOfIdentityProvider }}" >&2
                    echo "Verwendeter Scope: $GCP_STS_SCOPE" >&2
                    # uncomment when debugging
                    #echo "Verwendeter token: $K8S_TOKEN" >&2
                    exit 1
                  fi

                  # 3. GSA-Impersonation: STS Access Token gegen GSA Access Token tauschen (GAR-kompatibel)
                  {{- /* Generate an OIDC ID token for Identity-Aware Proxy
                       * See https://docs.cloud.google.com/iap/docs/authentication-howto#obtain_an_oidc_token_by_using_service_account_impersonation
                       * See https://docs.cloud.google.com/iam/docs/create-short-lived-credentials-direct#create-id
                       * REST API reference: https://docs.cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/generateIdToken
                       */}}
                  IAM_CRED_URL="https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/{{ .Values.gematik.serviceAccountEmailAddress }}:generateIdToken"
                  echo "used url for impersonation: $IAM_CRED_URL"

                  IMP_HTTP_CODE=$(curl -s -o /tmp/imp.json -w "%{http_code}" -X POST \
                    "$IAM_CRED_URL" \
                    -H "Authorization: Bearer ${GCP_ACCESS_TOKEN}" \
                    -H "Content-Type: application/json" \
                    -d '{"audience": "{{ .Values.gematik.clientId }}", "includeEmail": true}')
                  IMP_TOKEN=$(jq -r '.token' /tmp/imp.json 2>/dev/null || echo "")

                  if [ "$IMP_HTTP_CODE" != "200" ] || [ -z "$IMP_TOKEN" ] || [ "$IMP_TOKEN" = "null" ]; then
                    echo "FEHLER: GSA-Impersonation fehlgeschlagen (HTTP $IMP_HTTP_CODE)." >&2
                    echo "Antwort IAM Credentials API:" >&2
                    cat /tmp/imp.json >&2 || true
                    exit 1
                  fi

                  # 4. Das Secret 'gematik-oidc-token' mit dem neuen, base64-kodierten Token patchen
                  # Zuerst die Klartext-Datei, dann base64-kodiere den Dateiinhalt.
                  echo -n "${IMP_TOKEN}" > /tmp/gar_basic.txt
                  ENCODED_TOKEN=$(base64 -w0 /tmp/gar_basic.txt 2>/dev/null || base64 /tmp/gar_basic.txt | tr -d '\n')

                  kubectl patch secret gematik-oidc-token \
                    --type='json' \
                    -p="[{\"op\": \"replace\", \"path\": \"/data/token\", \"value\": \"${ENCODED_TOKEN}\"}]"
                  kubectl annotate --overwrite secret gematik-oidc-token last-updated="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"

                  echo "Kubernetes Secret 'gematik-oidc-token' aktualisiert (Basic-Pr채fix gesetzt)."

              volumeMounts:
                - name: gcp-sa-token
                  mountPath: /var/run/secrets/sts.googleapis.com/serviceaccount
          volumes:
            - name: gcp-sa-token
              projected:
                sources:
                  - serviceAccountToken:
                      audience: "{{ include "gematik.token-audience" . }}"
                      expirationSeconds: 3600
                      path: token
{{- end }}
